#+TITLE: java 设计模式
#+AUTHOR: Sunkehui
#+DATE: <2019-02-02>
#+HTML_LINK_UP: ../../index.html
#+LINK_UP: ../../index.html


#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://cdn.staticfile.org/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/readtheorg/js/readtheorg.js"></script>


* UML 图示及plantuml 语法
** 泛化（Generalization） is-a
就是我们熟悉的继承。
#+begin_src plantuml :file isa.png
Animal <|-- Tiger
#+end_src
#+RESULTS:
[[file:isa.png]]

plantuml 语法如下。
#+begin_example
Animal <|-- Tiger
#+end_example
** 实现（Realization）
就是接口的实现
#+begin_src plantuml :file realization.png
interface IBrush
IBrush <|.. PenBrush
#+end_src


#+RESULTS:
[[file:realization.png]]


#+begin_example
interface IBrush
IBrush <|.. PenBrush

#+end_example

** 聚合（Aggregation）


#+begin_src plantuml :file aggregation.png
Class Car{
}
Class Engine{
}
Class 轮胎{
}

Car "1" o-- "1" Engine
Car "1" o-- "4" 轮胎
#+end_src

#+RESULTS:
[[file:aggregation.png]]


#+begin_example
Class Car{
}
Class Engine{
}
Class 轮胎{
}

Car "1" o-- "1" Engine
Car "1" o-- "4" 轮胎

#+end_example


"has-a" 关系，依赖关系较弱，一个车 ，少一个轮子，也叫车。

** 组合(Composition)
#+begin_src plantuml :file composition.png

公司 *-- 财务部
公司 *-- 研发部
#+end_src

#+RESULTS:
[[file:composition.png]]

"contains-a"关系， 依赖关系较强，所以是实心的。
#+begin_example
公司 *-- 财务部
公司 *-- 研发部

#+end_example




* Structural Patterns
** 适配器模式 Adapter
将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
  其实现方式主要有两种：

1. 类的适配器模式（采用继承实现）
2. 对象适配器（采用对象组合方式实现）


组合方式的例子

#+begin_src java
public class XpayToPayDAdapter implements PayD{
private final Xpay xpay;
public XpayToPayDAdapter(Xpay xpay){
}
#+end_src
** Facade模式[fəˈsɑːd]
Facade模式可以用于，封闭复杂子系统， 或者分层系统，
#+begin_src java
package com.javacodegeeks.patterns.facadepattern;
public class ScheduleServerFacade {

  private final ScheduleServer scheduleServer;

  public ScheduleServerFacade(ScheduleServer scheduleServer){
    this.scheduleServer = scheduleServer;
  }
  public void startServer(){
    scheduleServer.startBooting();
    scheduleServer.readSystemConfigFile();
    scheduleServer.init();
    scheduleServer.initializeContext();
    scheduleServer.initializeListeners();
    scheduleServer.createSystemObjects();
  }
  public void stopServer(){
    scheduleServer.releaseProcesses();
    scheduleServer.destory();
    scheduleServer.destroySystemObjects();
    scheduleServer.destoryListeners();
    scheduleServer.destoryContext();
    scheduleServer.shutdown();
  }
}
#+end_src

此例对外屏蔽scheduleServer的启动停止过程的细节。
** Composite Patten构成模式
觉见的应用就是树，有四个参与者， Client 树的使用者， Component元件（叶和非叶的公共接口），leaf叶子节点， Composite非叶节点
比如，HTML解析这种场景就适合使用构成模式。

#+begin_src plantuml :file composite.png
class Client{
}
class Component{
add(Component)
remove(Component)
getChildren()

}
class Leaf{
}
Class Composite{
}
Component <|--  Leaf

Component <|-- Composite

Client -- Component : use >
#+end_src

#+RESULTS:
[[file:composite.png]]
** Bridge Pattern
 桥接模式，实现上是桥接了两条线， 一条是以Abstract Class为基础的类继承序列，另一条是以Interface 为基础的实现序列。
通过在AbsttractClass中的一个成员变量，使用构成（聚合）的方法，桥接接口序列.

#+begin_src plantuml :file bridge.png
Class Car{
 Engine engine
}
Class Bus{
}
Class Jeep{
}
Car <|-- Bus
Car <|-- Jeep

Interface Engine

Class Engine2000
Class Engine2200

Engine <|.. Engine2000
Engine <|.. Engine2200

Car o-- Engine : "Bridge"

#+end_src

#+RESULTS:
[[file:bridge.png]]

左边一条线：
#+begin_src java
package com.qianyan.bridge;

public abstract class Car {

  private Engine engine;

  public Car(Engine engine) {
    this.engine = engine;
  }

  public Engine getEngine() {
    return engine;
  }

  public void setEngine(Engine engine) {
    this.engine = engine;
  }

  public abstract void installEngine();
}

public class Bus extends Car {

  public Bus(Engine engine) {
    super(engine);
  }

  @Override
  public void installEngine() {
    System.out.print("Bus:");
    this.getEngine().installEngine();
  }

  public class Jeep extends Car {

    public Jeep(Engine engine) {
      super(engine);
    }
    @Override
    public void installEngine() {
      System.out.print("Jeep:");
      this.getEngine().installEngine();
    }

#+end_src


右边一条线
#+begin_src java
public interface Engine {

        /**
         * 安装发动引擎
         */
        public void installEngine();
}
public class Engine2000 implements Engine {

        @Override
        public void installEngine() {
                System.out.println("安装2000CC发动引擎");
        }

}
public class Engine2200 implements Engine {

        @Override
        public void installEngine() {
                System.out.println("安装2200CC发动引擎");
        }

}


#+end_src

使用方法
#+begin_src java
public class MainClass {
        public static void main(String[] args) {
                Engine engine2000 = new Engine2000();
                Engine engine2200 = new Engine2200();

                Car bus = new Bus(engine2000);
                bus.installEngine();

                Car jeep = new Jeep(engine2200);
                jeep.installEngine();
        }
}
#+end_src

为了更好的理解 桥接模式的用途，我们来想象一下如果不用桥接，这要怎么实现.

#+begin_src plantuml :file nonbridge.png
Car <|-- Engine2000Bus
Car <|-- Engine2200Bus
Car <|-- Engine2000Jeep
Car <|-- Engine2200Jeep
#+end_src
** Proxy Pattern

有很多变种 ，Remote Proxy, Virtual Proxy,and Protection Proxy

为什么需要代理，因为被代理的对象
- may be remote
- expensive to create
- in need of being secured.

** Flyweight Pattern 享元模式
面向对象编程让程序员的生活变得有趣而简单， 编程成了对现实的model化。
但创建和保存太多的对象，会占用系统过多的内存资源。所以好的程序员要学习控制对象的创建。
如果对象相似，比如大多数属性值是一样的，只有少量属性有变化， 就要想办法共享。

有这样一个平台，用户可以选择编辑语言，和运行平台，然后这个平台替你运行并返回结果。

#+begin_src java
public class Code {
  private String code;

  public String getCode() {
    return code;
  }
  public void setCode(String code) {
    this.code = code;
  }
}

#+end_src
Code是一个轻量型对象。只是代表一段代码。
#+begin_src java
public interface Platform {
  public void execute(Code code);
}
public class JavaPlatform implements Platform {
  public JavaPlatform(){
    System.out.println("JavaPlatform object created");
  }
  @Override
  public void execute(Code code) {
    System.out.println("Compiling and executing Java code.");
  }
}
#+end_src

platform系统的对象是重型对象，建立环境还需要很多对象。

#+begin_src java
Platform platform = new JavaPlatform();
platform.execute(code);

#+end_src

当有2K的用户在线的时候，就要创建2k的Code对象，和2k的Platform对象。

#+begin_quote
A flyweight is a shared object that can be used in multiple contexts simultaneously.
#+end_quote

这所以能够实现y共享，是因为将享元的属性状态分成了两类
- intrinsic state 内在状态 ， 在所有环境下都一样的状态属性
- extrinsic state 外在状态， 环境不同，属性状态不同
intrinsic state 是可以被共享的，extrinsic 是不能共享的。

享元模式的UML图是这样的



#+begin_src plantuml :file flyweight.png
interface Flyweight{
operation(extrinsicState)
}
class ConcreteFlyweight{
operation(extrinsicState)
}

FlyweightFactory o-- Flyweight
Flyweight <|.. ConcreteFlyweight

FlyweightFactory <-- Client
ConcreteFlyweight <-- Client


#+end_src

#+RESULTS:
[[file:flyweight.png]]


FlyweightFactory 是共享对象池，使用map 存储共享对象。 共享对象，通过 向操作 函数传入外在状态属性值来使用对象。

针对我们上面使用的场景， platform 没有内在对象，只有一个外在对象，code, 通过 excute函数可以传入code.
我们来看一下factory的实现
#+begin_src java
public final class PlatformFactory {
  private static Map<String, Platform> map = new HashMap<>();
  private PlatformFactory(){
    throw new AssertionError("Cannot instantiate the class");
  }
  public static synchronized Platform getPlatformInstance(String platformType){
    Platform platform = map.get(platformType);
    if(platform==null){
      switch(platformType){
      case "C" : platform = new CPlatform();
        break;
      case "CPP" : platform = new CPPPlatform();
        break;
      case "JAVA" : platform = new JavaPlatform();
        break;
      case "RUBY" : platform = new RubyPlatform();
        break;
      }
      map.put(platformType, platform);
    }
    return platform;
  }
}
#+end_src

注意Map本身是不同步的，所以 getPlatforminstance就一定要同步，否则影响对象创建。
使用方法如下。

#+begin_src java
public class TestFlyweight {
  public static void main(String[] args) {
    Code code = new Code();
    code.setCode("C Code...");
    Platform platform = PlatformFactory.getPlatformInstance("C");
    platform.execute(code);
    System.out.println("*************************");
    code = new Code();
    code.setCode("C Code2...");
    platform = PlatformFactory.getPlatformInstance("C");
    platform.execute(code);
    System.out.println("*************************");
    code = new Code();
    code.setCode("JAVA Code...");
    platform = PlatformFactory.getPlatformInstance("JAVA");
    platform.execute(code);

    System.out.println("*************************");
  }}


#+end_src

对就UML图， Platform 就相当于Flyweight接口。 JavaPlatform相当于ConcreteFlyweight.
而excute方法就是operation方法 。




* Creational Patterns

** 单例模式
懒汉式
#+begin_src java
class Singleton
{
  private static Singleton instance = new Singleton();
  private Singleton()
  {
    //
  }

  public static Singleton getInstance()
  {
    return instance;
  }
}
#+end_src

懒汉式的缺点是，类加载时就要实例化了。 而不是第一次调用时实例化。

改进方法如下


#+begin_src java

public class Singleton
{
  // Private constructor prevents instantiation from other classes
  private Singleton(){}

  /**
  * SingletonHolder is loaded on the first execution of Singleton.getInstance()
  * or the first access to SingletonHolder.INSTANCE, not before.
  */
  private final static class SingletonHolder
  {
      private final static Singleton instance = new Singleton();
  }

  public static Singleton getInstance()
  {
      return SingletonHolder.instance;
  }
}
#+end_src






** Builder Pattern

回想一下之前写C++程序的时候， 一个类，有很多成员变量，这些成员变量，有的是字符串，有的整型，有的是其它对象。这些成员变量有的是这个类实例化必要的，有的是可选的。
于是，这个类的构造函数，就搞得很复杂， 需要有很多参数的构造函数，构造流程也很复杂。 Bulder 模式就是为了解决这个问题，它有两种形式。

先看第一种，对于上面所述的问题，以前一般是通过建立Telescoping（可伸缩）的构造函数序列。 比如有一个表单，前四个字段是必须的，
其它都是可选的。
#+begin_src java
public class Form {


  private String firstName;
  private String lastName;
  private String userName;
  private String password;
  private String address;
  private Date dob;
  private String email;
  private String backupEmail;
  private String spouseName;
  private String city;

  private String state;
  private String country;
  private String language;
  private String passwordHint;
  private String secuirtyQuestion;
  private String securityAnswer;
}
#+end_src
它的构造函数就可以这么写,
#+begin_src java
public Form(String firstName,String lastName){
  this(firstName,lastName,null,null);
}
public Form(String firstName,String lastName,String userName,String password){
  this(firstName,lastName,userName,password,null,null);
}
public Form(String firstName,String lastName,String userName,String password,String address ←-
            ,Date dob){
  this(firstName,lastName,userName,password,address,dob,null,null);
}
public Form(String firstName,String lastName,String userName,String password,String address ←-
            ,Date dob,String email,String backupEmail){

}
#+end_src
这就叫telesoping. 这个存在的问题是什么 ， 是client在用这个类的时间，可读性着， client还要清楚每一个参数的意思、顺序、类型，
一旦出了问题，最差的情况是顺序错了，但类型一样，编译器没报错，运行起来才出问题。

#+begin_src java
public class Form {
  private String firstName;
  private String lastName;
  private String userName;
  private String password;
  private String address;
  private Date dob;
  private String email;
  private String backupEmail;
  private String spouseName;
  private String city;

  private String state;
  private String country;
  private String language;
  private String passwordHint;
  private String secuirtyQuestion;
  private String securityAnswer;
  public static class FormBuilder {
    private String firstName;
    private String lastName;
    private String userName;
    private String password;
    private String address;
    private Date dob;
    private String email;
    private String backupEmail;
    private String spouseName;
    private String city;

    private String state;
    private String country;
    private String language;
    private String passwordHint;
    private String secuirtyQuestion;
    private String securityAnswer;
    public FormBuilder(String firstName, String lastName, String userName,
                       String password){
      this.firstName = firstName;
      this.lastName = lastName;
      this.userName = userName;
      this.password = password;
    }
    public FormBuilder address(String address){
      this.address = address;
      return this;
    }
    public FormBuilder dob(Date dob){
      this.dob = dob;
      return this;
    }
    public FormBuilder email(String email){
      this.email = email;
      return this;
    }
    public FormBuilder backupEmail(String backupEmail){
      this.backupEmail = backupEmail;
      return this;
    }
    public FormBuilder spouseName(String spouseName){
      this.spouseName = spouseName;
      return this;
    }
    public FormBuilder city(String city){
      this.city = city;
      return this;
    }
    public FormBuilder state(String state){
      this.state = state;
      return this;
    }
    public FormBuilder country(String country){
      this.country = country;
      return this;
    }
    public FormBuilder language(String language){
      this.language = language;
      return this;
    }
    public FormBuilder passwordHint(String passwordHint){
      this.passwordHint = passwordHint;
      return this;
    }
    public FormBuilder securityQuestion(String securityQuestion){
      this.securityQuestion = securityQuestion;
      return this;
    }
    public FormBuilder securityAnswer(String securityAnswer){
      this.securityAnswer = securityAnswer;
      return this;
    }
    public Form build(){
      return new Form(this);
    }
  }
  private Form(FormBuilder formBuilder){
    this.firstName = formBuilder.firstName;
    this.lastName = formBuilder.lastName;
    this.userName = formBuilder.userName;
    this.password = formBuilder.password;
    this.address = formBuilder.address;
    this.dob = formBuilder.dob;
    this.email = formBuilder.email;
    this.backupEmail = formBuilder.backupEmail;
    this.spouseName = formBuilder.spouseName;
    this.city = formBuilder.city;
    this.state = formBuilder.state;
    this.country = formBuilder.country;
    this.language = formBuilder.language;
    this.passwordHint = formBuilder.passwordHint;
    this.securityQuestion = formBuilder.securityQuestion;
    this.securityAnswer = formBuilder.securityAnswer;
  }
  @Override
  public String toString(){
    StringBuilder sb = new StringBuilder();
    sb.append(" First Name: ");
    sb.append(firstName);
    sb.append("\\n Last Name: ");
    sb.append(lastName);
    sb.append("\\n User Name: ");
    sb.append(userName);
    sb.append("\\n Password: ");
    sb.append(password);
    if(this.address!=null){
      sb.append("\\n Address: ");
      sb.append(address);
    }
    if(this.dob!=null){
      sb.append("\\n DOB: ");
      sb.append(dob);
    }
    if(this.email!=null){
      sb.append("\\n Email: ");
      sb.append(email);
    }
    if(this.backupEmail!=null){
      sb.append("\\n Backup Email: ");
      sb.append(backupEmail);
    }
    if(this.spouseName!=null){
      sb.append("\\n Spouse Name: ");
      sb.append(spouseName);
    }
    if(this.city!=null){
      sb.append("\\n City: ");
      sb.append(city);
    }
    if(this.state!=null){
      sb.append("\\n State: ");
      sb.append(state);
    }
    if(this.country!=null){
      sb.append("\\n Country: ");
      sb.append(country);
    }
    if(this.language!=null){
      sb.append("\\n Language: ");
      sb.append(language);
    }
    if(this.passwordHint!=null){
      sb.append("\\n Password Hint: ");
      sb.append(passwordHint);
    }
    if(this.securityQuestion!=null){
      sb.append("\\n Security Question: ");
      sb.append(securityQuestion);
    }
    if(this.securityAnswer!=null){
      sb.append("\\n Security Answer: ");
      sb.append(securityAnswer);
    }
    return sb.toString();
  }
  public static void main(String[] args) {
    Form form = new Form.FormBuilder("Dave", "Carter", "DavCarter", "DAvCaEr123").passwordHint("MyName").city("NY").language("English").build();
    System.out.println(form);
  }
}

#+end_src

这就是第一种构建模式， FormBuilder构造函数参数只是必要的四个，其它通过方法来设计，最后通过build()方法来构建对象。
第一种形式适用于对象依赖很多很复杂的情景。

第二种构建模式的形式，稍复杂一些，适用于构建步骤复杂，但能分得出几步的情况。
比如说，需要为某个汽车渲染引擎提供汽车对象， 对象的构造步骤如下，buildBodyStyle()、buildPower()、buildEngine()、buildBreaks()
buildSeats()、buildWindows()等等。 所以你可定义一个Bulder接口定义这些步骤。 对于具体的车比如轿车SedanCar和SportsCar实现
具体Builder。 用户可以直接使用这些Builder，但更好的方法是提供一个Facade模式的对象，替用户实现构建细节。

#+begin_src plantuml :file bulder.png
class Direct{
construct()
}
Interface Builder{
buildStep()
}
class SimpleBuilder{
buildStep()
getResult()
}

Builder <|.. SimpleBuilder
Direct o-- Builder



#+end_src

#+RESULTS:
[[file:bulder.png]]


Direct 就是facade模式，construct方法按顺序调用builder的每个buildStep

#+begin_src java

public class Car {

  private String bodyStyle;
  private String power;
  private String engine;
  private String breaks;
  private String seats;
  private String windows;
  private String fuelType;
  private String carType;
  public Car (String carType){
    this.carType = carType;
  }
  public String getBodyStyle() {
    return bodyStyle;
  }
  public void setBodyStyle(String bodyStyle) {
    this.bodyStyle = bodyStyle;
  }
  public String getPower() {
    return power;
  }
  public void setPower(String power) {
    this.power = power;
  }
  public String getEngine() {
    return engine;
  }
  public void setEngine(String engine) {
    this.engine = engine;
  }
  public String getBreaks() {
    return breaks;
  }
  public void setBreaks(String breaks) {
    this.breaks = breaks;
  }
  public String getSeats() {
    return seats;
  }
  public void setSeats(String seats) {
    this.seats = seats;
  }
  public String getWindows() {
    return windows;
  }
  public void setWindows(String windows) {
    this.windows = windows;
  }
  public String getFuelType() {
    return fuelType;
  }
  @Override
  public String toString(){
    StringBuilder sb = new StringBuilder();
    sb.append("--------------"+carType+"--------------------- \\n");
    sb.append(" Body: ");
    sb.append(bodyStyle);
    ...
      return sb.toString();
  }
}

public interface CarBuilder {


  public void buildBodyStyle();
  public void buildPower();
  public void buildEngine();
  public void buildBreaks();
  public void buildSeats();
  public void buildWindows();
  public void buildFuelType();
  public Car getCar();
}

public class SedanCarBuilder implements CarBuilder{
  private final Car car = new Car("SEDAN");
  @Override
  public void buildBodyStyle() {
    car.setBodyStyle("External dimensions: overall length (inches): 202.9, " +
                     "overall width (inches): 76.2, overall height (inches): ←-
60.7, wheelbase (inches): 112.9," +
                     " front track (inches): 65.3, rear track (inches): 65.5 and ←-
curb to curb turning circle (feet): 39.5");
  }
  ...
    @Override
    public Car getCar(){
      return car;
    }
}
public class SportsCarBuilder implements CarBuilder{
  private final Car car = new Car("SPORTS");
  @Override
  public void buildBodyStyle() {
    car.setBodyStyle("External dimensions: overall length (inches): 192.3," +
                     " overall width (inches): 75.5, overall height (inches): ←-
54.2, wheelbase (inches): 112.3," +
                     " front track (inches): 63.7, rear track (inches): 64.1 and ←-
curb to curb turning circle (feet): 37.7");
  }
  ...
    @Override
    public Car getCar(){
      return car;
    }
}
public class CarDirector {
  private CarBuilder carBuilder;
  public CarDirector(CarBuilder carBuilder){
    this.carBuilder = carBuilder;
  }
  public build(){
    this.carBuilder.buildBodyStyle()
    this.carBuilder.buildPower();
    this.carBuilder.buildEngine();
    this.carBuilder.buildBreaks();
    this.carBuilder.buildSeats();
    this.carBuilder.buildWindows();
    this.carBuilder.buildFuelType();
  }
  @Override
  public Car getCar(){
    return this.carBuilder.car;
  }

}

public class TestBuilderPattern {
  public static void main(String[] args) {
    CarBuilder carBuilder = new SedanCarBuilder();
    CarDirector director = new CarDirector(carBuilder);
    director.build();
    Car car = carBuilder.getCar();
    System.out.println(car);
    carBuilder = new SportsCarBuilder();
    director = new CarDirector(carBuilder);
    director.build();
    car = carBuilder.getCar();
    System.out.println(car);
  }
}

#+end_src

** Factory Method Pattern
就是定义一个创建对象的接口，然后让子类去实现接口，去选择用使用哪个类去实例化， 工厂模式让类的实例化过程推迟到了子类。
其目的是封装concrete具体类型的初始化过程。 工厂方法依据应用的上下文和其它影响因素，从类继承树上，选择合适的类，实例化，初始化后返回。
这能避免client 去处理选择类的问题。
#+begin_src plantuml :file factory.png
interface Product{
}
class ConcreteProduct{
}

class Creator{
operation()
abstract factoryMethod()
}

class ConcreteCreator{
factoryMethod()
}

Product <|.. ConcreteProduct
Creator <|-- ConcreteCreator

ConcreteProduct <.. ConcreteCreator

#+end_src

#+RESULTS:
[[file:factory.png]]

Product 这一侧就是类的继承树。  Creator 的factoryMethod是让子类覆盖的，来选择创建合适的Product。 Creator的operation()方法，是用来调用factoryMethod()创建出Product然后提供一个服务的。

比如说，我们的产品是一套XML解析器，要依据不用的XML文件类型，提供不用的解析器
#+begin_src java
public interface XMLParser {
  public String parse();
}
public class ErrorXMLParser implements XMLParser{
  @Override
  public String parse() {
    System.out.println("Parsing error XML...");
    return "Error XML Message";
  }
}
public class FeedbackXML implements XMLParser{
  @Override
  public String parse() {
    System.out.println("Parsing feedback XML...");
    return "Feedback XML Message";
  }
}


public class OrderXMLParser implements XMLParser{
  @Override
  public String parse() {
    System.out.println("Parsing order XML...");
    return "Order XML Message";
  }
}
public class ResponseXMLParser implements XMLParser{
  @Override
  public String parse() {
    System.out.println("Parsing response XML...");
    return "Response XML Message";
  }
}
#+end_src
然后我们提供一个Creator类
#+begin_src java
public abstract class DisplayService {
  public void display(){
    XMLParser parser = getParser();
    String msg = parser.parse();
    System.out.println(msg);
  }
  protected abstract XMLParser getParser();

}

#+end_src

这个工厂类，提供的工厂方法是getParse(),提供的服务是display();
OK,接下来是各个ConcreteCreator的实现。
#+begin_src java

public class ErrorXMLDisplayService extends DisplayService{
  @Override
  public XMLParser getParser() {
    return new ErrorXMLParser();
  }
}

public class FeedbackXMLDisplayService extends DisplayService{
  @Override
  public XMLParser getParser() {
    return new FeedbackXML();
  }
}

public class OrderXMLDisplayService extends DisplayService{
  @Override
  public XMLParser getParser() {
    return new OrderXMLParser();
  }
}

public class ResponseXMLDisplayService extends DisplayService{
  @Override
  public XMLParser getParser() {
    return new ResponseXMLParser();
  }
}
#+end_src

然后就是使用方法
#+begin_src java
public class TestFactoryMethodPattern {
  public static void main(String[] args) {
    DisplayService service = new FeedbackXMLDisplayService();
    service.display();
    service = new ErrorXMLDisplayService();
    service.display();
    service = new OrderXMLDisplayService();
    service.display();
    service = new ResponseXMLDisplayService();
    service.display();
  }
}
#+end_src

什么情况下使用工厂模式
- 一个class没办法预计到将要创建的w具体是哪一个类
- 想让它的子类去指定创建哪个类
- 一个类负责代理多个helper subclass, 你想本地集中管理


** Abstract Factory Method Design Pattern抽象工厂模式
是工厂模式的下一级，是工厂的工厂。

为什么工厂还需要工厂呢？
我们看到工厂模式, 是concreteFactory来继承Factory.  这就造成了所有的concreteFactory是平行的。 是不能分组的。

比如XMLParser， 有ErrorXmlParser、MessageXmlParser等等。 假如这个时候， 允许由不同的厂商来定义parser了。 那就会有，ChromeErrorXmlParser
AdobeMessageXmlParser等等， 同一个公司的Parser应该有一个factory来创建， 而所有factory的接口就是抽象factory.


when a client object wants to create an instance of one of a suite of related，dependent
classes without having to know which specific concrete class is to be instantiated.
用于向系统中插入一组不同的对象来改变系统行为。

#+begin_src plantuml :file abstractFactory.png
interface Product

Product <|.. ProductA

Product <|.. ProductB

interface AbstractFactory

AbstractFactory <|.. FactoryA
AbstractFactory <|.. FactoryB


#+end_src

#+RESULTS:
[[file:abstractFactory.png]]

其实工厂模式的主要用途就是为了对client屏蔽product关系树的复杂性。用户不必知道具体实例化的是哪一个produce，只需要知道如何使用factory就可以。

product一侧
#+begin_src java
public interface XMLParser {
  public String parse();
}
public class NYErrorXMLParser implements XMLParser{
  @Override
  public String parse() {
    System.out.println("NY Parsing error XML...");
    return "NY Error XML Message";
  }
}

public class NYFeedbackXMLParser implements XMLParser{
  @Override
  public String parse() {
    System.out.println("NY Parsing feedback XML...");
    return "NY Feedback XML Message";
  }
}

public class NYOrderXMLParser implements XMLParser{
  @Override
  public String parse() {
    System.out.println("NY Parsing order XML...");
    return "NY Order XML Message";
  }
}
public class NYResponseXMLParser implements XMLParser{
  @Override
  public String parse() {
    System.out.println("NY Parsing response XML...");
    return "NY Response XML Message";
  }
}

public class TWErrorXMLParser implements XMLParser{
  @Override
  public String parse() {
    System.out.println("TW Parsing error XML...");
    return "TW Error XML Message";
  }
}
public class TWFeedbackXMLParser implements XMLParser{
  @Override
  public String parse() {
    System.out.println("TW Parsing feedback XML...");
    return "TW Feedback XML Message";
  }
}

public class TWOrderXMLParser implements XMLParser{
  @Override
  public String parse() {
    System.out.println("TW Parsing order XML...");
    return "TW Order XML Message";
  }
}

public class TWResponseXMLParser implements XMLParser{
  @Override
  public String parse() {
    System.out.println("TW Parsing response XML...");
    return "TW Response XML Message";
  }
}
#+end_src

我们依照这个关系，可以创建两个工厂。
#+begin_src java
public interface AbstractParserFactory {
  public XMLParser getParserInstance(String parserType);
}

public class NYParserFactory implements AbstractParserFactory {
  @Override
  public XMLParser getParserInstance(String parserType) {
    switch(parserType){
    case "NYERROR": return new NYErrorXMLParser();
    case "NYFEEDBACK": return new NYFeedbackXMLParser ();
    case "NYORDER": return new NYOrderXMLParser();
    case "NYRESPONSE": return new NYResponseXMLParser();
    }
    return null;
  }
}

public class TWParserFactory implements AbstractParserFactory {
  @Override
  public XMLParser getParserInstance(String parserType) {
    switch(parserType){
    case "TWERROR": return new TWErrorXMLParser();
    case "TWFEEDBACK": return new TWFeedbackXMLParser ();
    case "TWORDER": return new TWOrderXMLParser();
    case "TWRESPONSE": return new TWResponseXMLParser();
    }
    return null;
  }
}
#+end_src

可选了，你可以再定义一个类，来向用户屏蔽工厂复杂性。
#+begin_src java
public final class ParserFactoryProducer {
  private ParserFactoryProducer(){
    throw new AssertionError();
  }
  public static AbstractParserFactory getFactory(String factoryType){
    switch(factoryType)
      {
      case "NYFactory": return new NYParserFactory();
      case "TWFactory": return new TWParserFactory();
      }
    return null;
  }
}


#+end_src


** Prototype Pattern 原型模式
就是对象不直接创建，而通过复制已经创建好的原型对象，来创建。以此来提高性能。
我只觉得这只适用于要创建的对象是几个固定的状态对象时，才适用这种模式。

比如用于的访问权限管理
- "USER"
- "ADMIN" add/remove USERS
- "MANAGER" read/generate reports
- "VP" modify reports

我们假设给你一个control level 比如ADMIN。你要知道他都有什么权限需要查询数据库。 那么每创建一个ADMIN的controllevel
就都需要查询一次数据库， 这显示不如复制已经创建好的ADMIN来的快。

原型模式的实现方式是继承java clonable，重写它的clone()方法。
#+begin_src java
public interface Prototype extends Cloneable {
  public AccessControl clone() throws CloneNotSupportedException;
}

public class AccessControl implements Prototype{
  private final String controlLevel;
  private String access;
  public AccessControl(String controlLevel,String access){
    this.controlLevel = controlLevel;
    this.access = access;
  }
  @Override
  public AccessControl clone(){
    try {
      return (AccessControl) super.clone();
    } catch (CloneNotSupportedException e) {
      e.printStackTrace();
    }
    return null;
  }
  public String getControlLevel(){
    return controlLevel;
  }
  public String getAccess() {
    return access;
  }
  public void setAccess(String access) {
    this.access = access;
  }
}
#+end_src

我们看到是调用了super.clone()也就是Cloneable的clone(), 换句话说Cloneable不只是接口还有clone的实现，虽然不知道
是什么实现的。

总之是先super.clone(), 然后再类型转换为AccessControl并返回。

然后我们通过一个工厂先把对象创建好。
#+begin_src java
public class AccessControlProvider {
  private static Map<String, AccessControl>map = new HashMap<String, AccessControl>() ←-
    ;
  static{
    System.out.println("Fetching data from external resources and creating ←-
access control objects...");
    map.put("USER", new AccessControl("USER","DO_WORK"));
    map.put("ADMIN", new AccessControl("ADMIN","ADD/REMOVE USERS"));
    map.put("MANAGER", new AccessControl("MANAGER","GENERATE/READ REPORTS"));
    map.put("VP", new AccessControl("VP","MODIFY REPORTS"));
  }
  public static AccessControl getAccessControlObject(String controlLevel){
    AccessControl ac = null;
    ac = map.get(controlLevel);
    if(ac!=null){
      return ac.clone();
    }
    return null;
  }
}
#+end_src

然后我们就可以这样去使用了
#+begin_src java
userAccessControl = AccessControlProvider.getAccessControlObject("USER");
user = new User("User B", "USER Level", userAccessControl);
#+end_src
* Behavioral Patterns

** Observer Pattern观察者模式
观察模式 即发布订阅模式， 从第一理解性上，发布订阅更好更好理解。 发布者就是被观察者， 订阅者就是观察者。

订阅者，订阅观察者以后，就被加入到发布者管理的订阅者数组里， 当发布者想发布事件时，就循环调用数组中订阅者接口。

java.util.Observable 提供了被观察者的实现 java.util.Observer提供了观察者接口。注意这个名字是observ er 不是ob server
观察者，有update(Observable o, Object arg)方法，当被观察者调用
setChanged();
notifyObservers(homework);

notifyObservers函数就是循环调用，observer的update方法。

observable.addObserver observable.deleteObserver 管理观察者数组


被观察者observable又被称为Subjet目标。

** Mediator Design Pattern 中介者模式
比如 一个洗衣机Machine, 需要控制马达Motor的开启，依据用户选的衣服类型设置马达转速，根据衣服类型选择使用洗涤剂或者柔顺剂，依据温度传感器的温度，调整使用热水还是凉水。
这样， 机器  马达 配置内存  洗涤剂或者柔顺 温度传感器 水阀 ， 这些对象之间就要有关联和控制， 如果没有中介者， 程序会相当复杂，偶合度高，部件重用性小。

中介者，就是这些部件的中介， 每一个部件，只需要知道使用哪个中介，和中介都 有哪些操作可以使用， 中介自己去实现调用哪个部件。

** Chain of Responsibility Pattern责任链模式

一组对象按一定顺序被链接在一起， 一个责任(请求)，如果在当前对象中可以被处理，则处理完成后返回结果，如果处理不了，递交给后一个对象来处理。
#+begin_src plantuml :file chain.png
Interface Handler{
  Handler handler
  setHandler(Handler)
}
Handler o-- Handler
Handler <|.. ConcreteHandlerA
Handler <|.. ConcreteHandlerB


#+end_src

#+RESULTS:
[[file:chain.png]]

关键点是 Handler 里有一个指向下一个Handler的指针


* ref
http://plantuml.com/zh/class-diagram
