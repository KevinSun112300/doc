#+TITLE: java 设计模式
#+AUTHOR: Sunkehui
#+DATE: <2019-02-02>
#+HTML_LINK_UP: ../../index.html
#+LINK_UP: ../../index.html


#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://cdn.staticfile.org/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/readtheorg/js/readtheorg.js"></script>


* UML 图示及plantuml 语法
** 泛化（Generalization） is-a
就是我们熟悉的继承。
#+begin_src plantuml :file isa.png
Animal <|-- Tiger
#+end_src
#+RESULTS:
[[file:isa.png]]

plantuml 语法如下。
#+begin_example
Animal <|-- Tiger
#+end_example
** 实现（Realization）
就是接口的实现
#+begin_src plantuml :file realization.png
interface IBrush
IBrush <|.. PenBrush
#+end_src


#+RESULTS:
[[file:realization.png]]


#+begin_example
interface IBrush
IBrush <|.. PenBrush

#+end_example

** 聚合（Aggregation）


#+begin_src plantuml :file aggregation.png
Class Car{
}
Class Engine{
}
Class 轮胎{
}

Car "1" o-- "1" Engine
Car "1" o-- "4" 轮胎
#+end_src

#+RESULTS:
[[file:aggregation.png]]


#+begin_example
Class Car{
}
Class Engine{
}
Class 轮胎{
}

Car "1" o-- "1" Engine
Car "1" o-- "4" 轮胎

#+end_example


"has-a" 关系，依赖关系较弱，一个车 ，少一个轮子，也叫车。

** 组合(Composition)
#+begin_src plantuml :file composition.png

公司 *-- 财务部
公司 *-- 研发部
#+end_src

#+RESULTS:
[[file:composition.png]]

"contains-a"关系， 依赖关系较强，所以是实心的。
#+begin_example
公司 *-- 财务部
公司 *-- 研发部

#+end_example




* Structural Patterns
** 适配器模式 Adapter
将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
  其实现方式主要有两种：

1. 类的适配器模式（采用继承实现）
2. 对象适配器（采用对象组合方式实现）


组合方式的例子

#+begin_src java
public class XpayToPayDAdapter implements PayD{
private final Xpay xpay;
public XpayToPayDAdapter(Xpay xpay){
}
#+end_src
** Facade模式[fəˈsɑːd]
Facade模式可以用于，封闭复杂子系统， 或者分层系统，
#+begin_src java
package com.javacodegeeks.patterns.facadepattern;
public class ScheduleServerFacade {

  private final ScheduleServer scheduleServer;

  public ScheduleServerFacade(ScheduleServer scheduleServer){
    this.scheduleServer = scheduleServer;
  }
  public void startServer(){
    scheduleServer.startBooting();
    scheduleServer.readSystemConfigFile();
    scheduleServer.init();
    scheduleServer.initializeContext();
    scheduleServer.initializeListeners();
    scheduleServer.createSystemObjects();
  }
  public void stopServer(){
    scheduleServer.releaseProcesses();
    scheduleServer.destory();
    scheduleServer.destroySystemObjects();
    scheduleServer.destoryListeners();
    scheduleServer.destoryContext();
    scheduleServer.shutdown();
  }
}
#+end_src

此例对外屏蔽scheduleServer的启动停止过程的细节。
** Composite Patten构成模式
觉见的应用就是树，有四个参与者， Client 树的使用者， Component元件（叶和非叶的公共接口），leaf叶子节点， Composite非叶节点
比如，HTML解析这种场景就适合使用构成模式。

#+begin_src plantuml :file composite.png
class Client{
}
class Component{
add(Component)
remove(Component)
getChildren()

}
class Leaf{
}
Class Composite{
}
Component <|--  Leaf

Component <|-- Composite

Client -- Component : use >
#+end_src

#+RESULTS:
[[file:composite.png]]
** Bridge Pattern
 桥接模式，实现上是桥接了两条线， 一条是以Abstract Class为基础的类继承序列，另一条是以Interface 为基础的实现序列。
通过在AbsttractClass中的一个成员变量，使用构成（聚合）的方法，桥接接口序列.

#+begin_src plantuml :file bridge.png
Class Car{
 Engine engine
}
Class Bus{
}
Class Jeep{
}
Car <|-- Bus
Car <|-- Jeep

Interface Engine

Class Engine2000
Class Engine2200

Engine <|.. Engine2000
Engine <|.. Engine2200

Car o-- Engine : "Bridge"

#+end_src

#+RESULTS:
[[file:bridge.png]]

左边一条线：
#+begin_src java
package com.qianyan.bridge;

public abstract class Car {

  private Engine engine;

  public Car(Engine engine) {
    this.engine = engine;
  }

  public Engine getEngine() {
    return engine;
  }

  public void setEngine(Engine engine) {
    this.engine = engine;
  }

  public abstract void installEngine();
}

public class Bus extends Car {

  public Bus(Engine engine) {
    super(engine);
  }

  @Override
  public void installEngine() {
    System.out.print("Bus:");
    this.getEngine().installEngine();
  }

  public class Jeep extends Car {

    public Jeep(Engine engine) {
      super(engine);
    }
    @Override
    public void installEngine() {
      System.out.print("Jeep:");
      this.getEngine().installEngine();
    }

#+end_src


右边一条线
#+begin_src java
public interface Engine {

        /**
         * 安装发动引擎
         */
        public void installEngine();
}
public class Engine2000 implements Engine {

        @Override
        public void installEngine() {
                System.out.println("安装2000CC发动引擎");
        }

}
public class Engine2200 implements Engine {

        @Override
        public void installEngine() {
                System.out.println("安装2200CC发动引擎");
        }

}


#+end_src

使用方法
#+begin_src java
public class MainClass {
        public static void main(String[] args) {
                Engine engine2000 = new Engine2000();
                Engine engine2200 = new Engine2200();

                Car bus = new Bus(engine2000);
                bus.installEngine();

                Car jeep = new Jeep(engine2200);
                jeep.installEngine();
        }
}
#+end_src

为了更好的理解 桥接模式的用途，我们来想象一下如果不用桥接，这要怎么实现.

#+begin_src plantuml :file nonbridge.png
Car <|-- Engine2000Bus
Car <|-- Engine2200Bus
Car <|-- Engine2000Jeep
Car <|-- Engine2200Jeep
#+end_src
** Proxy Pattern

有很多变种 ，Remote Proxy, Virtual Proxy,and Protection Proxy

为什么需要代理，因为被代理的对象
- may be remote
- expensive to create
- in need of being secured.

** Flyweight Pattern 享元模式
面向对象编程让程序员的生活变得有趣而简单， 编程成了对现实的model化。
但创建和保存太多的对象，会占用系统过多的内存资源。所以好的程序员要学习控制对象的创建。
如果对象相似，比如大多数属性值是一样的，只有少量属性有变化， 就要想办法共享。

有这样一个平台，用户可以选择编辑语言，和运行平台，然后这个平台替你运行并返回结果。

#+begin_src java
public class Code {
  private String code;

  public String getCode() {
    return code;
  }
  public void setCode(String code) {
    this.code = code;
  }
}

#+end_src
Code是一个轻量型对象。只是代表一段代码。
#+begin_src java
public interface Platform {
  public void execute(Code code);
}
public class JavaPlatform implements Platform {
  public JavaPlatform(){
    System.out.println("JavaPlatform object created");
  }
  @Override
  public void execute(Code code) {
    System.out.println("Compiling and executing Java code.");
  }
}
#+end_src

platform系统的对象是重型对象，建立环境还需要很多对象。

#+begin_src java
Platform platform = new JavaPlatform();
platform.execute(code);

#+end_src

当有2K的用户在线的时候，就要创建2k的Code对象，和2k的Platform对象。

#+begin_quote
A flyweight is a shared object that can be used in multiple contexts simultaneously.
#+end_quote

这所以能够实现y共享，是因为将享元的属性状态分成了两类
- intrinsic state 内在状态 ， 在所有环境下都一样的状态属性
- extrinsic state 外在状态， 环境不同，属性状态不同
intrinsic state 是可以被共享的，extrinsic 是不能共享的。

享元模式的UML图是这样的



#+begin_src plantuml :file flyweight.png
interface Flyweight{
operation(extrinsicState)
}
class ConcreteFlyweight{
operation(extrinsicState)
}

FlyweightFactory o-- Flyweight
Flyweight <|.. ConcreteFlyweight

FlyweightFactory <-- Client
ConcreteFlyweight <-- Client


#+end_src

#+RESULTS:
[[file:flyweight.png]]


FlyweightFactory 是共享对象池，使用map 存储共享对象。 共享对象，通过 向操作 函数传入外在状态属性值来使用对象。

针对我们上面使用的场景， platform 没有内在对象，只有一个外在对象，code, 通过 excute函数可以传入code.
我们来看一下factory的实现
#+begin_src java
public final class PlatformFactory {
  private static Map<String, Platform> map = new HashMap<>();
  private PlatformFactory(){
    throw new AssertionError("Cannot instantiate the class");
  }
  public static synchronized Platform getPlatformInstance(String platformType){
    Platform platform = map.get(platformType);
    if(platform==null){
      switch(platformType){
      case "C" : platform = new CPlatform();
        break;
      case "CPP" : platform = new CPPPlatform();
        break;
      case "JAVA" : platform = new JavaPlatform();
        break;
      case "RUBY" : platform = new RubyPlatform();
        break;
      }
      map.put(platformType, platform);
    }
    return platform;
  }
}
#+end_src

注意Map本身是不同步的，所以 getPlatforminstance就一定要同步，否则影响对象创建。
使用方法如下。

#+begin_src java
public class TestFlyweight {
  public static void main(String[] args) {
    Code code = new Code();
    code.setCode("C Code...");
    Platform platform = PlatformFactory.getPlatformInstance("C");
    platform.execute(code);
    System.out.println("*************************");
    code = new Code();
    code.setCode("C Code2...");
    platform = PlatformFactory.getPlatformInstance("C");
    platform.execute(code);
    System.out.println("*************************");
    code = new Code();
    code.setCode("JAVA Code...");
    platform = PlatformFactory.getPlatformInstance("JAVA");
    platform.execute(code);

    System.out.println("*************************");
  }}


#+end_src

对就UML图， Platform 就相当于Flyweight接口。 JavaPlatform相当于ConcreteFlyweight.
而excute方法就是operation方法 。

* Creational Patterns

** 单例模式
懒汉式
#+begin_src java
class Singleton
{
  private static Singleton instance = new Singleton();
  private Singleton()
  {
    //
  }

  public static Singleton getInstance()
  {
    return instance;
  }
}
#+end_src

懒汉式的缺点是，类加载时就要实例化了。 而不是第一次调用时实例化。

改进方法如下


#+begin_src java

public class Singleton
{
  // Private constructor prevents instantiation from other classes
  private Singleton(){}

  /**
  * SingletonHolder is loaded on the first execution of Singleton.getInstance()
  * or the first access to SingletonHolder.INSTANCE, not before.
  */
  private final static class SingletonHolder
  {
      private final static Singleton instance = new Singleton();
  }

  public static Singleton getInstance()
  {
      return SingletonHolder.instance;
  }
}
#+end_src







* Behavioral Patterns

** Observer Pattern观察者模式
观察模式 即发布订阅模式， 从第一理解性上，发布订阅更好更好理解。 发布者就是被观察者， 订阅者就是观察者。

订阅者，订阅观察者以后，就被加入到发布者管理的订阅者数组里， 当发布者想发布事件时，就循环调用数组中订阅者接口。

java.util.Observable 提供了被观察者的实现 java.util.Observer提供了观察者接口。注意这个名字是observ er 不是ob server
观察者，有update(Observable o, Object arg)方法，当被观察者调用
setChanged();
notifyObservers(homework);

notifyObservers函数就是循环调用，observer的update方法。

observable.addObserver observable.deleteObserver 管理观察者数组


被观察者observable又被称为Subjet目标。

** Mediator Design Pattern 中介者模式
比如 一个洗衣机Machine, 需要控制马达Motor的开启，依据用户选的衣服类型设置马达转速，根据衣服类型选择使用洗涤剂或者柔顺剂，依据温度传感器的温度，调整使用热水还是凉水。
这样， 机器  马达 配置内存  洗涤剂或者柔顺 温度传感器 水阀 ， 这些对象之间就要有关联和控制， 如果没有中介者， 程序会相当复杂，偶合度高，部件重用性小。

中介者，就是这些部件的中介， 每一个部件，只需要知道使用哪个中介，和中介都 有哪些操作可以使用， 中介自己去实现调用哪个部件。

** Chain of Responsibility Pattern责任链模式

一组对象按一定顺序被链接在一起， 一个责任(请求)，如果在当前对象中可以被处理，则处理完成后返回结果，如果处理不了，递交给后一个对象来处理。
#+begin_src plantuml :file chain.png
Interface Handler{
  Handler handler
  setHandler(Handler)
}
Handler o-- Handler
Handler <|.. ConcreteHandlerA
Handler <|.. ConcreteHandlerB


#+end_src

#+RESULTS:
[[file:chain.png]]

关键点是 Handler 里有一个指向下一个Handler的指针


* ref
http://plantuml.com/zh/class-diagram
